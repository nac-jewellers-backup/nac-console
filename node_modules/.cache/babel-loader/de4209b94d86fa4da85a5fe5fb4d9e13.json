{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PivotData = exports.sortAs = exports.getSort = exports.numberFormat = exports.naturalSort = exports.locales = exports.derivers = exports.aggregators = exports.aggregatorTemplates = undefined;\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n/*\n * decaffeinate suggestions:\n * DS101: Remove unnecessary use of Array.from\n * DS102: Remove unnecessary code created because of implicit returns\n * DS104: Avoid inline assignments\n * DS201: Simplify complex destructure assignments\n * DS203: Remove `|| {}` from converted for-own loops\n * DS205: Consider reworking code to avoid use of IIFEs\n * DS207: Consider shorter variations of null checks\n * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md\n */\n\n\nvar addSeparators = function addSeparators(nStr, thousandsSep, decimalSep) {\n  var x = String(nStr).split('.');\n  var x1 = x[0];\n  var x2 = x.length > 1 ? decimalSep + x[1] : '';\n  var rgx = /(\\d+)(\\d{3})/;\n\n  while (rgx.test(x1)) {\n    x1 = x1.replace(rgx, '$1' + thousandsSep + '$2');\n  }\n\n  return x1 + x2;\n};\n\nvar numberFormat = function numberFormat(opts_in) {\n  var defaults = {\n    digitsAfterDecimal: 2,\n    scaler: 1,\n    thousandsSep: ',',\n    decimalSep: '.',\n    prefix: '',\n    suffix: ''\n  };\n  var opts = Object.assign({}, defaults, opts_in);\n  return function (x) {\n    if (isNaN(x) || !isFinite(x)) {\n      return '';\n    }\n\n    var result = addSeparators((opts.scaler * x).toFixed(opts.digitsAfterDecimal), opts.thousandsSep, opts.decimalSep);\n    return '' + opts.prefix + result + opts.suffix;\n  };\n};\n\nvar rx = /(\\d+)|(\\D+)/g;\nvar rd = /\\d/;\nvar rz = /^0/;\n\nvar naturalSort = function naturalSort(as, bs) {\n  // nulls first\n  if (bs !== null && as === null) {\n    return -1;\n  }\n\n  if (as !== null && bs === null) {\n    return 1;\n  } // then raw NaNs\n\n\n  if (typeof as === 'number' && isNaN(as)) {\n    return -1;\n  }\n\n  if (typeof bs === 'number' && isNaN(bs)) {\n    return 1;\n  } // numbers and numbery strings group together\n\n\n  var nas = Number(as);\n  var nbs = Number(bs);\n\n  if (nas < nbs) {\n    return -1;\n  }\n\n  if (nas > nbs) {\n    return 1;\n  } // within that, true numbers before numbery strings\n\n\n  if (typeof as === 'number' && typeof bs !== 'number') {\n    return -1;\n  }\n\n  if (typeof bs === 'number' && typeof as !== 'number') {\n    return 1;\n  }\n\n  if (typeof as === 'number' && typeof bs === 'number') {\n    return 0;\n  } // 'Infinity' is a textual number, so less than 'A'\n\n\n  if (isNaN(nbs) && !isNaN(nas)) {\n    return -1;\n  }\n\n  if (isNaN(nas) && !isNaN(nbs)) {\n    return 1;\n  } // finally, \"smart\" string sorting per http://stackoverflow.com/a/4373421/112871\n\n\n  var a = String(as);\n  var b = String(bs);\n\n  if (a === b) {\n    return 0;\n  }\n\n  if (!rd.test(a) || !rd.test(b)) {\n    return a > b ? 1 : -1;\n  } // special treatment for strings containing digits\n\n\n  a = a.match(rx);\n  b = b.match(rx);\n\n  while (a.length && b.length) {\n    var a1 = a.shift();\n    var b1 = b.shift();\n\n    if (a1 !== b1) {\n      if (rd.test(a1) && rd.test(b1)) {\n        return a1.replace(rz, '.0') - b1.replace(rz, '.0');\n      }\n\n      return a1 > b1 ? 1 : -1;\n    }\n  }\n\n  return a.length - b.length;\n};\n\nvar sortAs = function sortAs(order) {\n  var mapping = {}; // sort lowercased keys similarly\n\n  var l_mapping = {};\n\n  for (var i in order) {\n    var x = order[i];\n    mapping[x] = i;\n\n    if (typeof x === 'string') {\n      l_mapping[x.toLowerCase()] = i;\n    }\n  }\n\n  return function (a, b) {\n    if (a in mapping && b in mapping) {\n      return mapping[a] - mapping[b];\n    } else if (a in mapping) {\n      return -1;\n    } else if (b in mapping) {\n      return 1;\n    } else if (a in l_mapping && b in l_mapping) {\n      return l_mapping[a] - l_mapping[b];\n    } else if (a in l_mapping) {\n      return -1;\n    } else if (b in l_mapping) {\n      return 1;\n    }\n\n    return naturalSort(a, b);\n  };\n};\n\nvar getSort = function getSort(sorters, attr) {\n  if (sorters) {\n    if (typeof sorters === 'function') {\n      var sort = sorters(attr);\n\n      if (typeof sort === 'function') {\n        return sort;\n      }\n    } else if (attr in sorters) {\n      return sorters[attr];\n    }\n  }\n\n  return naturalSort;\n}; // aggregator templates default to US number formatting but this is overrideable\n\n\nvar usFmt = numberFormat();\nvar usFmtInt = numberFormat({\n  digitsAfterDecimal: 0\n});\nvar usFmtPct = numberFormat({\n  digitsAfterDecimal: 1,\n  scaler: 100,\n  suffix: '%'\n});\nvar aggregatorTemplates = {\n  count: function count() {\n    var formatter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : usFmtInt;\n    return function () {\n      return function () {\n        return {\n          count: 0,\n          push: function push() {\n            this.count++;\n          },\n          value: function value() {\n            return this.count;\n          },\n          format: formatter\n        };\n      };\n    };\n  },\n  uniques: function uniques(fn) {\n    var formatter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : usFmtInt;\n    return function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 1),\n          attr = _ref2[0];\n\n      return function () {\n        return {\n          uniq: [],\n          push: function push(record) {\n            if (!Array.from(this.uniq).includes(record[attr])) {\n              this.uniq.push(record[attr]);\n            }\n          },\n          value: function value() {\n            return fn(this.uniq);\n          },\n          format: formatter,\n          numInputs: typeof attr !== 'undefined' ? 0 : 1\n        };\n      };\n    };\n  },\n  sum: function sum() {\n    var formatter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : usFmt;\n    return function (_ref3) {\n      var _ref4 = _slicedToArray(_ref3, 1),\n          attr = _ref4[0];\n\n      return function () {\n        return {\n          sum: 0,\n          push: function push(record) {\n            if (!isNaN(parseFloat(record[attr]))) {\n              this.sum += parseFloat(record[attr]);\n            }\n          },\n          value: function value() {\n            return this.sum;\n          },\n          format: formatter,\n          numInputs: typeof attr !== 'undefined' ? 0 : 1\n        };\n      };\n    };\n  },\n  extremes: function extremes(mode) {\n    var formatter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : usFmt;\n    return function (_ref5) {\n      var _ref6 = _slicedToArray(_ref5, 1),\n          attr = _ref6[0];\n\n      return function (data) {\n        return {\n          val: null,\n          sorter: getSort(typeof data !== 'undefined' ? data.sorters : null, attr),\n          push: function push(record) {\n            var x = record[attr];\n\n            if (['min', 'max'].includes(mode)) {\n              x = parseFloat(x);\n\n              if (!isNaN(x)) {\n                this.val = Math[mode](x, this.val !== null ? this.val : x);\n              }\n            }\n\n            if (mode === 'first' && this.sorter(x, this.val !== null ? this.val : x) <= 0) {\n              this.val = x;\n            }\n\n            if (mode === 'last' && this.sorter(x, this.val !== null ? this.val : x) >= 0) {\n              this.val = x;\n            }\n          },\n          value: function value() {\n            return this.val;\n          },\n          format: function format(x) {\n            if (isNaN(x)) {\n              return x;\n            }\n\n            return formatter(x);\n          },\n          numInputs: typeof attr !== 'undefined' ? 0 : 1\n        };\n      };\n    };\n  },\n  quantile: function quantile(q) {\n    var formatter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : usFmt;\n    return function (_ref7) {\n      var _ref8 = _slicedToArray(_ref7, 1),\n          attr = _ref8[0];\n\n      return function () {\n        return {\n          vals: [],\n          push: function push(record) {\n            var x = parseFloat(record[attr]);\n\n            if (!isNaN(x)) {\n              this.vals.push(x);\n            }\n          },\n          value: function value() {\n            if (this.vals.length === 0) {\n              return null;\n            }\n\n            this.vals.sort(function (a, b) {\n              return a - b;\n            });\n            var i = (this.vals.length - 1) * q;\n            return (this.vals[Math.floor(i)] + this.vals[Math.ceil(i)]) / 2.0;\n          },\n          format: formatter,\n          numInputs: typeof attr !== 'undefined' ? 0 : 1\n        };\n      };\n    };\n  },\n  runningStat: function runningStat() {\n    var mode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'mean';\n    var ddof = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    var formatter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : usFmt;\n    return function (_ref9) {\n      var _ref10 = _slicedToArray(_ref9, 1),\n          attr = _ref10[0];\n\n      return function () {\n        return {\n          n: 0.0,\n          m: 0.0,\n          s: 0.0,\n          push: function push(record) {\n            var x = parseFloat(record[attr]);\n\n            if (isNaN(x)) {\n              return;\n            }\n\n            this.n += 1.0;\n\n            if (this.n === 1.0) {\n              this.m = x;\n            }\n\n            var m_new = this.m + (x - this.m) / this.n;\n            this.s = this.s + (x - this.m) * (x - m_new);\n            this.m = m_new;\n          },\n          value: function value() {\n            if (mode === 'mean') {\n              if (this.n === 0) {\n                return 0 / 0;\n              }\n\n              return this.m;\n            }\n\n            if (this.n <= ddof) {\n              return 0;\n            }\n\n            switch (mode) {\n              case 'var':\n                return this.s / (this.n - ddof);\n\n              case 'stdev':\n                return Math.sqrt(this.s / (this.n - ddof));\n\n              default:\n                throw new Error('unknown mode for runningStat');\n            }\n          },\n          format: formatter,\n          numInputs: typeof attr !== 'undefined' ? 0 : 1\n        };\n      };\n    };\n  },\n  sumOverSum: function sumOverSum() {\n    var formatter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : usFmt;\n    return function (_ref11) {\n      var _ref12 = _slicedToArray(_ref11, 2),\n          num = _ref12[0],\n          denom = _ref12[1];\n\n      return function () {\n        return {\n          sumNum: 0,\n          sumDenom: 0,\n          push: function push(record) {\n            if (!isNaN(parseFloat(record[num]))) {\n              this.sumNum += parseFloat(record[num]);\n            }\n\n            if (!isNaN(parseFloat(record[denom]))) {\n              this.sumDenom += parseFloat(record[denom]);\n            }\n          },\n          value: function value() {\n            return this.sumNum / this.sumDenom;\n          },\n          format: formatter,\n          numInputs: typeof num !== 'undefined' && typeof denom !== 'undefined' ? 0 : 2\n        };\n      };\n    };\n  },\n  fractionOf: function fractionOf(wrapped) {\n    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'total';\n    var formatter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : usFmtPct;\n    return function () {\n      for (var _len = arguments.length, x = Array(_len), _key = 0; _key < _len; _key++) {\n        x[_key] = arguments[_key];\n      }\n\n      return function (data, rowKey, colKey) {\n        return {\n          selector: {\n            total: [[], []],\n            row: [rowKey, []],\n            col: [[], colKey]\n          }[type],\n          inner: wrapped.apply(undefined, _toConsumableArray(Array.from(x || [])))(data, rowKey, colKey),\n          push: function push(record) {\n            this.inner.push(record);\n          },\n          format: formatter,\n          value: function value() {\n            return this.inner.value() / data.getAggregator.apply(data, _toConsumableArray(Array.from(this.selector || []))).inner.value();\n          },\n          numInputs: wrapped.apply(undefined, _toConsumableArray(Array.from(x || [])))().numInputs\n        };\n      };\n    };\n  }\n};\n\naggregatorTemplates.countUnique = function (f) {\n  return aggregatorTemplates.uniques(function (x) {\n    return x.length;\n  }, f);\n};\n\naggregatorTemplates.listUnique = function (s) {\n  return aggregatorTemplates.uniques(function (x) {\n    return x.join(s);\n  }, function (x) {\n    return x;\n  });\n};\n\naggregatorTemplates.max = function (f) {\n  return aggregatorTemplates.extremes('max', f);\n};\n\naggregatorTemplates.min = function (f) {\n  return aggregatorTemplates.extremes('min', f);\n};\n\naggregatorTemplates.first = function (f) {\n  return aggregatorTemplates.extremes('first', f);\n};\n\naggregatorTemplates.last = function (f) {\n  return aggregatorTemplates.extremes('last', f);\n};\n\naggregatorTemplates.median = function (f) {\n  return aggregatorTemplates.quantile(0.5, f);\n};\n\naggregatorTemplates.average = function (f) {\n  return aggregatorTemplates.runningStat('mean', 1, f);\n};\n\naggregatorTemplates.var = function (ddof, f) {\n  return aggregatorTemplates.runningStat('var', ddof, f);\n};\n\naggregatorTemplates.stdev = function (ddof, f) {\n  return aggregatorTemplates.runningStat('stdev', ddof, f);\n}; // default aggregators & renderers use US naming and number formatting\n\n\nvar aggregators = function (tpl) {\n  return {\n    Count: tpl.count(usFmtInt),\n    'Count Unique Values': tpl.countUnique(usFmtInt),\n    'List Unique Values': tpl.listUnique(', '),\n    Sum: tpl.sum(usFmt),\n    'Integer Sum': tpl.sum(usFmtInt),\n    Average: tpl.average(usFmt),\n    Median: tpl.median(usFmt),\n    'Sample Variance': tpl.var(1, usFmt),\n    'Sample Standard Deviation': tpl.stdev(1, usFmt),\n    Minimum: tpl.min(usFmt),\n    Maximum: tpl.max(usFmt),\n    First: tpl.first(usFmt),\n    Last: tpl.last(usFmt),\n    'Sum over Sum': tpl.sumOverSum(usFmt),\n    'Sum as Fraction of Total': tpl.fractionOf(tpl.sum(), 'total', usFmtPct),\n    'Sum as Fraction of Rows': tpl.fractionOf(tpl.sum(), 'row', usFmtPct),\n    'Sum as Fraction of Columns': tpl.fractionOf(tpl.sum(), 'col', usFmtPct),\n    'Count as Fraction of Total': tpl.fractionOf(tpl.count(), 'total', usFmtPct),\n    'Count as Fraction of Rows': tpl.fractionOf(tpl.count(), 'row', usFmtPct),\n    'Count as Fraction of Columns': tpl.fractionOf(tpl.count(), 'col', usFmtPct)\n  };\n}(aggregatorTemplates);\n\nvar locales = {\n  en: {\n    aggregators: aggregators,\n    localeStrings: {\n      renderError: 'An error occurred rendering the PivotTable results.',\n      computeError: 'An error occurred computing the PivotTable results.',\n      uiRenderError: 'An error occurred rendering the PivotTable UI.',\n      selectAll: 'Select All',\n      selectNone: 'Select None',\n      tooMany: '(too many to list)',\n      filterResults: 'Filter values',\n      apply: 'Apply',\n      cancel: 'Cancel',\n      totals: 'Totals',\n      vs: 'vs',\n      by: 'by'\n    }\n  }\n}; // dateFormat deriver l10n requires month and day names to be passed in directly\n\nvar mthNamesEn = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];\nvar dayNamesEn = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];\n\nvar zeroPad = function zeroPad(number) {\n  return ('0' + number).substr(-2, 2);\n}; // eslint-disable-line no-magic-numbers\n\n\nvar derivers = {\n  bin: function bin(col, binWidth) {\n    return function (record) {\n      return record[col] - record[col] % binWidth;\n    };\n  },\n  dateFormat: function dateFormat(col, formatString) {\n    var utcOutput = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var mthNames = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : mthNamesEn;\n    var dayNames = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : dayNamesEn;\n    var utc = utcOutput ? 'UTC' : '';\n    return function (record) {\n      var date = new Date(Date.parse(record[col]));\n\n      if (isNaN(date)) {\n        return '';\n      }\n\n      return formatString.replace(/%(.)/g, function (m, p) {\n        switch (p) {\n          case 'y':\n            return date['get' + utc + 'FullYear']();\n\n          case 'm':\n            return zeroPad(date['get' + utc + 'Month']() + 1);\n\n          case 'n':\n            return mthNames[date['get' + utc + 'Month']()];\n\n          case 'd':\n            return zeroPad(date['get' + utc + 'Date']());\n\n          case 'w':\n            return dayNames[date['get' + utc + 'Day']()];\n\n          case 'x':\n            return date['get' + utc + 'Day']();\n\n          case 'H':\n            return zeroPad(date['get' + utc + 'Hours']());\n\n          case 'M':\n            return zeroPad(date['get' + utc + 'Minutes']());\n\n          case 'S':\n            return zeroPad(date['get' + utc + 'Seconds']());\n\n          default:\n            return '%' + p;\n        }\n      });\n    };\n  }\n};\n/*\nData Model class\n*/\n\nvar PivotData = function () {\n  function PivotData() {\n    var _this = this;\n\n    var inputProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, PivotData);\n\n    this.props = Object.assign({}, PivotData.defaultProps, inputProps);\n\n    _propTypes2.default.checkPropTypes(PivotData.propTypes, this.props, 'prop', 'PivotData');\n\n    this.aggregator = this.props.aggregators[this.props.aggregatorName](this.props.vals);\n    this.tree = {};\n    this.rowKeys = [];\n    this.colKeys = [];\n    this.rowTotals = {};\n    this.colTotals = {};\n    this.allTotal = this.aggregator(this, [], []);\n    this.sorted = false; // iterate through input, accumulating data for cells\n\n    PivotData.forEachRecord(this.props.data, this.props.derivedAttributes, function (record) {\n      if (_this.filter(record)) {\n        _this.processRecord(record);\n      }\n    });\n  }\n\n  _createClass(PivotData, [{\n    key: 'filter',\n    value: function filter(record) {\n      for (var k in this.props.valueFilter) {\n        if (record[k] in this.props.valueFilter[k]) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: 'forEachMatchingRecord',\n    value: function forEachMatchingRecord(criteria, callback) {\n      var _this2 = this;\n\n      return PivotData.forEachRecord(this.props.data, this.props.derivedAttributes, function (record) {\n        if (!_this2.filter(record)) {\n          return;\n        }\n\n        for (var k in criteria) {\n          var v = criteria[k];\n\n          if (v !== (k in record ? record[k] : 'null')) {\n            return;\n          }\n        }\n\n        callback(record);\n      });\n    }\n  }, {\n    key: 'arrSort',\n    value: function arrSort(attrs) {\n      var _this3 = this;\n\n      var a = void 0;\n\n      var sortersArr = function () {\n        var result = [];\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = Array.from(attrs)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            a = _step.value;\n            result.push(getSort(_this3.props.sorters, a));\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n\n        return result;\n      }();\n\n      return function (a, b) {\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = Object.keys(sortersArr || {})[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var i = _step2.value;\n            var sorter = sortersArr[i];\n            var comparison = sorter(a[i], b[i]);\n\n            if (comparison !== 0) {\n              return comparison;\n            }\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n\n        return 0;\n      };\n    }\n  }, {\n    key: 'sortKeys',\n    value: function sortKeys() {\n      var _this4 = this;\n\n      if (!this.sorted) {\n        this.sorted = true;\n\n        var v = function v(r, c) {\n          return _this4.getAggregator(r, c).value();\n        };\n\n        switch (this.props.rowOrder) {\n          case 'value_a_to_z':\n            this.rowKeys.sort(function (a, b) {\n              return naturalSort(v(a, []), v(b, []));\n            });\n            break;\n\n          case 'value_z_to_a':\n            this.rowKeys.sort(function (a, b) {\n              return -naturalSort(v(a, []), v(b, []));\n            });\n            break;\n\n          default:\n            this.rowKeys.sort(this.arrSort(this.props.rows));\n        }\n\n        switch (this.props.colOrder) {\n          case 'value_a_to_z':\n            this.colKeys.sort(function (a, b) {\n              return naturalSort(v([], a), v([], b));\n            });\n            break;\n\n          case 'value_z_to_a':\n            this.colKeys.sort(function (a, b) {\n              return -naturalSort(v([], a), v([], b));\n            });\n            break;\n\n          default:\n            this.colKeys.sort(this.arrSort(this.props.cols));\n        }\n      }\n    }\n  }, {\n    key: 'getColKeys',\n    value: function getColKeys() {\n      this.sortKeys();\n      return this.colKeys;\n    }\n  }, {\n    key: 'getRowKeys',\n    value: function getRowKeys() {\n      this.sortKeys();\n      return this.rowKeys;\n    }\n  }, {\n    key: 'processRecord',\n    value: function processRecord(record) {\n      // this code is called in a tight loop\n      var colKey = [];\n      var rowKey = [];\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = Array.from(this.props.cols)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var x = _step3.value;\n          colKey.push(x in record ? record[x] : 'null');\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n      var _iteratorError4 = undefined;\n\n      try {\n        for (var _iterator4 = Array.from(this.props.rows)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n          var _x16 = _step4.value;\n          rowKey.push(_x16 in record ? record[_x16] : 'null');\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4.return) {\n            _iterator4.return();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n\n      var flatRowKey = rowKey.join(String.fromCharCode(0));\n      var flatColKey = colKey.join(String.fromCharCode(0));\n      this.allTotal.push(record);\n\n      if (rowKey.length !== 0) {\n        if (!this.rowTotals[flatRowKey]) {\n          this.rowKeys.push(rowKey);\n          this.rowTotals[flatRowKey] = this.aggregator(this, rowKey, []);\n        }\n\n        this.rowTotals[flatRowKey].push(record);\n      }\n\n      if (colKey.length !== 0) {\n        if (!this.colTotals[flatColKey]) {\n          this.colKeys.push(colKey);\n          this.colTotals[flatColKey] = this.aggregator(this, [], colKey);\n        }\n\n        this.colTotals[flatColKey].push(record);\n      }\n\n      if (colKey.length !== 0 && rowKey.length !== 0) {\n        if (!this.tree[flatRowKey]) {\n          this.tree[flatRowKey] = {};\n        }\n\n        if (!this.tree[flatRowKey][flatColKey]) {\n          this.tree[flatRowKey][flatColKey] = this.aggregator(this, rowKey, colKey);\n        }\n\n        this.tree[flatRowKey][flatColKey].push(record);\n      }\n    }\n  }, {\n    key: 'getAggregator',\n    value: function getAggregator(rowKey, colKey) {\n      var agg = void 0;\n      var flatRowKey = rowKey.join(String.fromCharCode(0));\n      var flatColKey = colKey.join(String.fromCharCode(0));\n\n      if (rowKey.length === 0 && colKey.length === 0) {\n        agg = this.allTotal;\n      } else if (rowKey.length === 0) {\n        agg = this.colTotals[flatColKey];\n      } else if (colKey.length === 0) {\n        agg = this.rowTotals[flatRowKey];\n      } else {\n        agg = this.tree[flatRowKey][flatColKey];\n      }\n\n      return agg || {\n        value: function value() {\n          return null;\n        },\n        format: function format() {\n          return '';\n        }\n      };\n    }\n  }]);\n\n  return PivotData;\n}(); // can handle arrays or jQuery selections of tables\n\n\nPivotData.forEachRecord = function (input, derivedAttributes, f) {\n  var addRecord = void 0,\n      record = void 0;\n\n  if (Object.getOwnPropertyNames(derivedAttributes).length === 0) {\n    addRecord = f;\n  } else {\n    addRecord = function addRecord(record) {\n      for (var k in derivedAttributes) {\n        var derived = derivedAttributes[k](record);\n\n        if (derived !== null) {\n          record[k] = derived;\n        }\n      }\n\n      return f(record);\n    };\n  } // if it's a function, have it call us back\n\n\n  if (typeof input === 'function') {\n    return input(addRecord);\n  } else if (Array.isArray(input)) {\n    if (Array.isArray(input[0])) {\n      // array of arrays\n      return function () {\n        var result = [];\n        var _iteratorNormalCompletion5 = true;\n        var _didIteratorError5 = false;\n        var _iteratorError5 = undefined;\n\n        try {\n          for (var _iterator5 = Object.keys(input || {})[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n            var i = _step5.value;\n            var compactRecord = input[i];\n\n            if (i > 0) {\n              record = {};\n              var _iteratorNormalCompletion6 = true;\n              var _didIteratorError6 = false;\n              var _iteratorError6 = undefined;\n\n              try {\n                for (var _iterator6 = Object.keys(input[0] || {})[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n                  var j = _step6.value;\n                  var k = input[0][j];\n                  record[k] = compactRecord[j];\n                }\n              } catch (err) {\n                _didIteratorError6 = true;\n                _iteratorError6 = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion6 && _iterator6.return) {\n                    _iterator6.return();\n                  }\n                } finally {\n                  if (_didIteratorError6) {\n                    throw _iteratorError6;\n                  }\n                }\n              }\n\n              result.push(addRecord(record));\n            }\n          }\n        } catch (err) {\n          _didIteratorError5 = true;\n          _iteratorError5 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion5 && _iterator5.return) {\n              _iterator5.return();\n            }\n          } finally {\n            if (_didIteratorError5) {\n              throw _iteratorError5;\n            }\n          }\n        }\n\n        return result;\n      }();\n    } // array of objects\n\n\n    return function () {\n      var result1 = [];\n      var _iteratorNormalCompletion7 = true;\n      var _didIteratorError7 = false;\n      var _iteratorError7 = undefined;\n\n      try {\n        for (var _iterator7 = Array.from(input)[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n          record = _step7.value;\n          result1.push(addRecord(record));\n        }\n      } catch (err) {\n        _didIteratorError7 = true;\n        _iteratorError7 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion7 && _iterator7.return) {\n            _iterator7.return();\n          }\n        } finally {\n          if (_didIteratorError7) {\n            throw _iteratorError7;\n          }\n        }\n      }\n\n      return result1;\n    }();\n  }\n\n  throw new Error('unknown input format');\n};\n\nPivotData.defaultProps = {\n  aggregators: aggregators,\n  cols: [],\n  rows: [],\n  vals: [],\n  aggregatorName: 'Count',\n  sorters: {},\n  valueFilter: {},\n  rowOrder: 'key_a_to_z',\n  colOrder: 'key_a_to_z',\n  derivedAttributes: {}\n};\nPivotData.propTypes = {\n  data: _propTypes2.default.oneOfType([_propTypes2.default.array, _propTypes2.default.object, _propTypes2.default.func]).isRequired,\n  aggregatorName: _propTypes2.default.string,\n  cols: _propTypes2.default.arrayOf(_propTypes2.default.string),\n  rows: _propTypes2.default.arrayOf(_propTypes2.default.string),\n  vals: _propTypes2.default.arrayOf(_propTypes2.default.string),\n  valueFilter: _propTypes2.default.objectOf(_propTypes2.default.objectOf(_propTypes2.default.bool)),\n  sorters: _propTypes2.default.oneOfType([_propTypes2.default.func, _propTypes2.default.objectOf(_propTypes2.default.func)]),\n  derivedAttributes: _propTypes2.default.objectOf(_propTypes2.default.func),\n  rowOrder: _propTypes2.default.oneOf(['key_a_to_z', 'value_a_to_z', 'value_z_to_a']),\n  colOrder: _propTypes2.default.oneOf(['key_a_to_z', 'value_a_to_z', 'value_z_to_a'])\n};\nexports.aggregatorTemplates = aggregatorTemplates;\nexports.aggregators = aggregators;\nexports.derivers = derivers;\nexports.locales = locales;\nexports.naturalSort = naturalSort;\nexports.numberFormat = numberFormat;\nexports.getSort = getSort;\nexports.sortAs = sortAs;\nexports.PivotData = PivotData;","map":null,"metadata":{},"sourceType":"script"}