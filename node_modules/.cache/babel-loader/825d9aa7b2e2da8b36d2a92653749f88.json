{"ast":null,"code":"/*!\n * FilePondPluginImageValidateSize 1.2.3\n * Licensed under MIT, https://opensource.org/licenses/MIT/\n * Please visit https://pqina.nl/filepond/ for details.\n */\n\n/* eslint-disable */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = global || self, global.FilePondPluginImageValidateSize = factory());\n})(this, function () {\n  'use strict'; // test if file is of type image\n\n  var isImage = function isImage(file) {\n    return /^image/.test(file.type);\n  };\n\n  var getImageSize = function getImageSize(file) {\n    return new Promise(function (resolve, reject) {\n      var image = document.createElement('img');\n      image.src = URL.createObjectURL(file);\n\n      image.onerror = function (err) {\n        clearInterval(intervalId);\n        reject(err);\n      };\n\n      var intervalId = setInterval(function () {\n        if (image.naturalWidth && image.naturalHeight) {\n          clearInterval(intervalId);\n          URL.revokeObjectURL(image.src);\n          resolve({\n            width: image.naturalWidth,\n            height: image.naturalHeight\n          });\n        }\n      }, 1);\n    });\n  };\n\n  var plugin = function plugin(_ref) {\n    var addFilter = _ref.addFilter,\n        utils = _ref.utils; // get quick reference to Type utils\n\n    var Type = utils.Type,\n        replaceInString = utils.replaceInString,\n        isFile = utils.isFile; // required file size\n\n    var validateFile = function validateFile(file, bounds, measure) {\n      return new Promise(function (resolve, reject) {\n        var onReceiveSize = function onReceiveSize(_ref2) {\n          var width = _ref2.width,\n              height = _ref2.height;\n          var minWidth = bounds.minWidth,\n              minHeight = bounds.minHeight,\n              maxWidth = bounds.maxWidth,\n              maxHeight = bounds.maxHeight,\n              minResolution = bounds.minResolution,\n              maxResolution = bounds.maxResolution;\n          var resolution = width * height; // validation result\n\n          if (width < minWidth || height < minHeight) {\n            reject('TOO_SMALL');\n          } else if (width > maxWidth || height > maxHeight) {\n            reject('TOO_BIG');\n          } else if (minResolution !== null && resolution < minResolution) {\n            reject('TOO_LOW_RES');\n          } else if (maxResolution !== null && resolution > maxResolution) {\n            reject('TOO_HIGH_RES');\n          } // all is well\n\n\n          resolve();\n        };\n\n        getImageSize(file).then(onReceiveSize).catch(function () {\n          // no custom measure method supplied, exit here\n          if (!measure) {\n            reject();\n            return;\n          } // try fallback if defined by user, else reject\n\n\n          measure(file, bounds).then(onReceiveSize).catch(function () {\n            return reject();\n          });\n        });\n      });\n    }; // called for each file that is loaded\n    // right before it is set to the item state\n    // should return a promise\n\n\n    addFilter('LOAD_FILE', function (file, _ref3) {\n      var query = _ref3.query;\n      return new Promise(function (resolve, reject) {\n        if (!isFile(file) || !isImage(file) || !query('GET_ALLOW_IMAGE_VALIDATE_SIZE')) {\n          resolve(file);\n          return;\n        } // get required dimensions\n\n\n        var bounds = {\n          minWidth: query('GET_IMAGE_VALIDATE_SIZE_MIN_WIDTH'),\n          minHeight: query('GET_IMAGE_VALIDATE_SIZE_MIN_HEIGHT'),\n          maxWidth: query('GET_IMAGE_VALIDATE_SIZE_MAX_WIDTH'),\n          maxHeight: query('GET_IMAGE_VALIDATE_SIZE_MAX_HEIGHT'),\n          minResolution: query('GET_IMAGE_VALIDATE_SIZE_MIN_RESOLUTION'),\n          maxResolution: query('GET_IMAGE_VALIDATE_SIZE_MAX_RESOLUTION')\n        }; // get optional custom measure function\n\n        var measure = query('GET_IMAGE_VALIDATE_SIZE_MEASURE');\n        validateFile(file, bounds, measure).then(function () {\n          resolve(file);\n        }).catch(function (error) {\n          var status = error ? {\n            TOO_SMALL: {\n              label: query('GET_IMAGE_VALIDATE_SIZE_LABEL_IMAGE_SIZE_TOO_SMALL'),\n              details: query('GET_IMAGE_VALIDATE_SIZE_LABEL_EXPECTED_MIN_SIZE')\n            },\n            TOO_BIG: {\n              label: query('GET_IMAGE_VALIDATE_SIZE_LABEL_IMAGE_SIZE_TOO_BIG'),\n              details: query('GET_IMAGE_VALIDATE_SIZE_LABEL_EXPECTED_MAX_SIZE')\n            },\n            TOO_LOW_RES: {\n              label: query('GET_IMAGE_VALIDATE_SIZE_LABEL_IMAGE_RESOLUTION_TOO_LOW'),\n              details: query('GET_IMAGE_VALIDATE_SIZE_LABEL_EXPECTED_MIN_RESOLUTION')\n            },\n            TOO_HIGH_RES: {\n              label: query('GET_IMAGE_VALIDATE_SIZE_LABEL_IMAGE_RESOLUTION_TOO_HIGH'),\n              details: query('GET_IMAGE_VALIDATE_SIZE_LABEL_EXPECTED_MAX_RESOLUTION')\n            }\n          }[error] : {\n            label: query('GET_IMAGE_VALIDATE_SIZE_LABEL_FORMAT_ERROR'),\n            details: file.type\n          };\n          reject({\n            status: {\n              main: status.label,\n              sub: error ? replaceInString(status.details, bounds) : status.details\n            }\n          });\n        });\n      });\n    }); // expose plugin\n\n    return {\n      // default options\n      options: {\n        // Enable or disable file type validation\n        allowImageValidateSize: [true, Type.BOOLEAN],\n        // Error thrown when image can not be loaded\n        imageValidateSizeLabelFormatError: ['Image type not supported', Type.STRING],\n        // Custom function to use as image measure\n        imageValidateSizeMeasure: [null, Type.FUNCTION],\n        // Required amount of pixels in the image\n        imageValidateSizeMinResolution: [null, Type.INT],\n        imageValidateSizeMaxResolution: [null, Type.INT],\n        imageValidateSizeLabelImageResolutionTooLow: ['Resolution is too low', Type.STRING],\n        imageValidateSizeLabelImageResolutionTooHigh: ['Resolution is too high', Type.STRING],\n        imageValidateSizeLabelExpectedMinResolution: ['Minimum resolution is {minResolution}', Type.STRING],\n        imageValidateSizeLabelExpectedMaxResolution: ['Maximum resolution is {maxResolution}', Type.STRING],\n        // Required dimensions\n        imageValidateSizeMinWidth: [1, Type.INT],\n        // needs to be at least one pixel\n        imageValidateSizeMinHeight: [1, Type.INT],\n        imageValidateSizeMaxWidth: [65535, Type.INT],\n        // maximum size of JPEG, fine for now I guess\n        imageValidateSizeMaxHeight: [65535, Type.INT],\n        // Label to show when an image is too small or image is too big\n        imageValidateSizeLabelImageSizeTooSmall: ['Image is too small', Type.STRING],\n        imageValidateSizeLabelImageSizeTooBig: ['Image is too big', Type.STRING],\n        imageValidateSizeLabelExpectedMinSize: ['Minimum size is {minWidth} × {minHeight}', Type.STRING],\n        imageValidateSizeLabelExpectedMaxSize: ['Maximum size is {maxWidth} × {maxHeight}', Type.STRING]\n      }\n    };\n  }; // fire pluginloaded event if running in browser, this allows registering the plugin when using async script tags\n\n\n  var isBrowser = typeof window !== 'undefined' && typeof window.document !== 'undefined';\n\n  if (isBrowser) {\n    document.dispatchEvent(new CustomEvent('FilePond:pluginloaded', {\n      detail: plugin\n    }));\n  }\n\n  return plugin;\n});","map":null,"metadata":{},"sourceType":"script"}